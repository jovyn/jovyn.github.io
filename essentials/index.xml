<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Essentials | HackTheRipper</title>
    <link>https://hacktheripper.com/essentials/</link>
      <atom:link href="https://hacktheripper.com/essentials/index.xml" rel="self" type="application/rss+xml" />
    <description>Essentials</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>www.hacktheripper.com  Â©  2020</copyright><lastBuildDate>Sun, 27 Sep 2020 15:51:19 +0530</lastBuildDate>
    <image>
      <url>https://hacktheripper.com/images/icon_hu617de424786793b3a09c4e0a85288893_17654_512x512_fill_lanczos_center_2.png</url>
      <title>Essentials</title>
      <link>https://hacktheripper.com/essentials/</link>
    </image>
    
    <item>
      <title>sed &amp; awk Tutorial</title>
      <link>https://hacktheripper.com/essentials/sed-n-awk/</link>
      <pubDate>Sun, 27 Sep 2020 15:51:19 +0530</pubDate>
      <guid>https://hacktheripper.com/essentials/sed-n-awk/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Credits -&lt;/strong&gt; These are my notes from 
&lt;a href=&#34;https://www.udemy.com/course/linux-bash-shell-scripting-complete-guide-incl-awk-sed/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richard Bohm&amp;rsquo;s Udemy Class&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sed&#34;&gt;SED&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SED is a stream editor.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;structure-&#34;&gt;Structure :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sed OPTIONS &amp;hellip; [SCRIPT] [INPUTFILE&amp;hellip;.]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cat [INPUTFILE] | sed OPTIONS &amp;hellip; [SCRIPT]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SCRIPT:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[addr]X[options]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[addr]&lt;/code&gt; - can be a single line, number, a regular expression, or range of lines. If &lt;code&gt;[addr]&lt;/code&gt; is specified, the command X will be executed only on the matched lines.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; - single-letter sed command.&lt;/li&gt;
&lt;li&gt;Additional &lt;code&gt;[options]&lt;/code&gt; for sed command.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eg:  &lt;code&gt;sed &#39;30,35d&#39; infile.txt &amp;gt; outfile.txt &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Delete range of lines Line 30 - line 35 from infile and save output to outfile.txt&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; - is the delete command&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sed by default does not alter the inputfile, only prints.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sed accepts one single command at a time. To use multiple commands use &lt;code&gt;-e&lt;/code&gt; option&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3 ways to specify multiple instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Using &lt;code&gt;;&lt;/code&gt; . Eg : &lt;code&gt;sed &#39;s/abc/replace/; s/pqr/replace2/&#39; inputfile&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using the precedence &amp;lsquo;-e&amp;rsquo; . Eg:   &lt;code&gt;sed &#39;s/abc/replace/&#39; -e  &#39;s/pqr/replace2/&#39; inputfile&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiline entry:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       $ sed &#39;
       &amp;gt; s/Red/Ray/
       &amp;gt; s/Dev/Development/
       &amp;gt; &#39; emp.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example-file-to-be-used-throughout--emptxt&#34;&gt;Example file to be used throughout : emp.txt&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    cat emp.txt

    output:
    Name Age Unit
    Ant  23  IT
    Bec  25  HT
    Red  34  CEO
    Dua  32  FIN
    Wui  29  PR
    Wui  29  PR
    Van  27  Dev
    Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;sed-commands-&#34;&gt;Sed Commands :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; -  Append text after a line.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg: Append after IT some text : &lt;code&gt; sed &#39;/IT/a QWE  ## XY&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      output:
      Name Age Unit
      Ant  23  IT
      QWE  ## XY
      Bec  25  HT
      Red  34  CEO
      Dua  32  FIN
      Wui  29  PR
      Van  27  Dev
      Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;i &#39;text&#39;&lt;/code&gt; - insert text before a line&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg: Insert before IT some text : &lt;code&gt; sed &#39;/IT/i QWE  ## XY&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      output:
      Name Age Unit
      QWE  ## XY
      Ant  23  IT
      Bec  25  HT
      Red  34  CEO
      Dua  32  FIN
      Wui  29  PR
      Van  27  Dev
      Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;/code&gt; - delete the pattern&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg: Delete all lines containing &amp;lsquo;Dev&amp;rsquo; : &lt;code&gt; sed &#39;/Dev/d&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
  Wui  29  PR
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p &lt;/code&gt; - print the pattern.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg:  &lt;code&gt; sed -n &#39;/Dev/p&#39; emp.txt&lt;/code&gt; &amp;lsquo;-n&amp;rsquo; is used to explicitly disable print all, as sed prints all by default.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Van  27  Dev
  Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eg: &amp;ldquo;Print 2nd line&amp;rdquo;  &lt;code&gt;sed -n &#39;2p&#39; emp.txt &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Ant  23  IT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eg: &amp;ldquo;Print from line 2 to 5&amp;rdquo;  &lt;code&gt;sed -n &#39;2,5p&#39; emp.txt &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt; - Change command used to change lines.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg: Change all lines with &amp;lsquo;Dev&amp;rsquo; to XXXXXX&amp;hellip; - &lt;code&gt; sed &#39;/Dev/c xxxxxxxxxxxxxxxxxxxxxxx&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   output:
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
  Wui  29  PR
  xxxxxxxxxxxxxxxxxxxxxxx
  xxxxxxxxxxxxxxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;q[exit-code]&lt;/code&gt; - exit sed without processing any more commands or input.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg:  &lt;code&gt;sed &#39;/Bec/q2&#39; emp.txt&lt;/code&gt; will quit once the search pattern matches and will receive exit status code 2. &lt;code&gt;echo $?&lt;/code&gt; gives an output of &lt;code&gt; 2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; s/regexp/replacement/[flags]&lt;/code&gt; - (substitute) Match the regex against the content of the pattern space. If found replace matched string with &amp;lsquo;replacement&amp;rsquo;. Use &lt;code&gt;g &lt;/code&gt; to substitute globally.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Eg: &lt;code&gt;echo &amp;quot;1110000111&amp;quot; | sed &#39;s/000/XXX/&#39;&lt;/code&gt; &amp;ndash;&amp;gt; output:  &lt;code&gt;111XXX0111&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eg: &lt;code&gt; echo &amp;quot;The quick brown fox  , trots away     ...  &amp;quot; | sed &#39;s/[[:space:]]/#/g&#39;&lt;/code&gt;. This will replaces all spaces globally. Output : &lt;code&gt;The#quick#brown#fox##,#trots#away#####...##&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eg: &lt;code&gt;echo &amp;quot;The quick brown fox  , trots away     ...  &amp;quot; | sed &#39;s/[[:space:]]/#/&lt;/code&gt; . Without the global flag (g) will simply replace the first instance. &amp;ndash;&amp;gt; output: &lt;code&gt;The#quick brown fox  , trots away     ...  &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eg: Replace specific lines in a file. &lt;code&gt;sed &#39;8s/Dev/Manager/&#39; emp.txt&lt;/code&gt; &amp;ndash;&amp;gt; Replace &amp;lsquo;Dev&amp;rsquo; with &amp;lsquo;Manager&amp;rsquo; on the 8th line.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
  Wui  29  PR
  Van  27  Dev
  Kim  26  Manager
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eg: Replace  all lines we use range &lt;code&gt;1,$&lt;/code&gt;. Use command &lt;code&gt;sed &#39;1,$s/e/EE/&#39; emp.txt&lt;/code&gt; to replace all instances of &amp;lsquo;e&amp;rsquo; with &amp;lsquo;EE&amp;rsquo;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  NamEE Age Unit
  Ant  23  IT
  BEEc  25  HT
  REEd  34  CEO
  Dua  32  FIN
  Wui  29  PR
  Van  27  DEEv
  Kim  26  DEEv
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Command-Line- Options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; - disable automatic printing; sed produced output when explicitlytold via the p command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-e script&lt;/code&gt; - add script&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg:  Search some text and quit with exit code 2 : &lt;code&gt;sed -ne &#39;/CEO/p&#39; -ne &#39;/CEO/q2&#39; emp.txt &lt;/code&gt; and &lt;code&gt;echo $?&lt;/code&gt; will return 2.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Red  34  CEO
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eg: Print &amp;ldquo;000- before/after -000&amp;rdquo; before and after lines containing &amp;lsquo;Dua&amp;rsquo; :  &lt;code&gt;sed -e &#39;/Dua/a 000- after -000&#39; -e &#39;/Dua/i 000- before -000&#39; emp.txt &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  000- before -000
  Dua  32  FIN
  000- after -000
  Wui  29  PR
  Van  27  Dev
  Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; - use extended regular expressions rather than basic regular expressions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; - Use this flag to modify the input file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We take a copy of emp.txt as emp2.txt and perform the following :  &lt;code&gt; sed -ni &#39;/Wui/p&#39; emp2.txt&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cat emp2.txt&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Wui  29  PR
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;e&lt;/code&gt; To run scripts. This is different than &lt;code&gt;-e&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sed &#39;/Name/e echo -n &amp;quot;Date:&amp;quot;; date&#39; emp.txt&lt;/code&gt;  - Run and print date before &amp;lsquo;Name&amp;rsquo;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Date:Sat Aug 29 08:00:34 IST 2020
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
  Wui  29  PR
  Van  27  Dev
  Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sed &#39;1 e echo -n &amp;quot;Date:&amp;quot;; date&#39; emp.txt&lt;/code&gt; - Print date on the first line.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Date:Sat Aug 29 08:05:41 IST 2020
  Name Age Unit
  Ant  23  IT
  Bec  25  HT
  Red  34  CEO
  Dua  32  FIN
  Wui  29  PR
  Van  27  Dev
  Kim  26  Dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; sed &#39;1,$ e echo -n &amp;quot;Date:&amp;quot;; date&#39; emp.txt&lt;/code&gt; - Print date before every line.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  Date:Sat Aug 29 08:16:09 IST 2020
  Name Age Unit
  Date:Sat Aug 29 08:16:09 IST 2020
  Ant  23  IT
  Date:Sat Aug 29 08:16:09 IST 2020
  Bec  25  HT
  Date:Sat Aug 29 08:16:09 IST 2020
  Red  34  CEO
  Date:Sat Aug 29 08:16:09 IST 2020
  Dua  32  FIN
  Date:Sat Aug 29 08:16:09 IST 2020
  Wui  29  PR
  Date:Sat Aug 29 08:16:09 IST 2020
  Van  27  Dev
  Date:Sat Aug 29 08:16:09 IST 2020
  Kim  26  Dev
  Date:Sat Aug 29 08:16:09 IST 2020
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sed-commands--1&#34;&gt;Sed Commands :&lt;/h4&gt;
&lt;p&gt;Its not advised to have long sed scripts on commndline, a better option is to  create a script file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Syntax:  sed -f scriptfile inputfile. Where scriptfile contains the sed instructions.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;awk&#34;&gt;AWK&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Searches files for patterns and performs actions specified in the AWK body.&lt;/p&gt;
&lt;h4 id=&#34;structure--1&#34;&gt;Structure :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; awk&#39;program_to_perform_action&#39; file1 file2 ...&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Divided into 3 sections BEGIN, Main &amp;amp; END&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BEGIN - Code specified here is executed before executing the operations on the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main - Executed for ech line of the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;END - After awk process of all lines.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; awk &#39;BEGIN{
     code_in_BEGIN_section}
 {Code_in_Main_Body}
 END{
     code_END_Section }&#39; file1 file2 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    echo &amp;quot;one two three&amp;quot; | awk&#39;BEGIN{begin_code}{main_code}END{end_code}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    echo &amp;quot;one two three&amp;quot; | awk&#39;{main_code}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;note-in-awk-body-bash-features-do-not-work-awk-has-its-own-syntax&#34;&gt;[NOTE] In AWK body, Bash features DO NOT WORK. AWK has its own syntax.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hello World: &lt;code&gt;awk &#39;BEGIN{print &amp;quot;Hello world !&amp;quot;}&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To print &amp;ldquo;Hello World !&amp;rdquo; on each line after Enter &lt;code&gt;awk &#39;{print &amp;quot;Hello world !&amp;quot;}&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Example: &lt;code&gt;echo &amp;quot;This is one line&amp;quot; | awk &#39;BEGIN{print &amp;quot;start&amp;quot;}{print &amp;quot;OK&amp;quot;}END{print &amp;quot;stop&amp;quot;}&#39;&lt;/code&gt; The output is as shown below. OK is printed once as there is just one line.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Output:
  start
  OK
  stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Example (lets input a file hello.txt which has 3 lines): &lt;code&gt;cat hello.txt | awk &#39;BEGIN{print &amp;quot;start&amp;quot;}{print &amp;quot;OK&amp;quot;}END{print &amp;quot;stop&amp;quot;}&#39;&lt;/code&gt; OR &lt;code&gt;awk &#39;BEGIN{print &amp;quot;start&amp;quot;}{print &amp;quot;OK&amp;quot;}END{print &amp;quot;stop&amp;quot;}&#39; hello.txt &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  output:
  start
  OK
  OK
  OK
  stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fields-&#34;&gt;Fields :&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fields are by default seperated by space.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$0&lt;/code&gt; prints entire line&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$1&lt;/code&gt; prints the first field and so on ..&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;1 2 3 4 5&amp;quot; | awk &#39;{print $0}&#39;&lt;/code&gt; will output &lt;code&gt;1 2 3 4 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;1 2 3 4 5&amp;quot; | awk &#39;{print $1}&#39;&lt;/code&gt; will output &lt;code&gt; 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;1 2 3 4 5&amp;quot; | awk &#39;{print $3}&#39;&lt;/code&gt; will output &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples with a File (emp.txt)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To print all columns in the file &lt;code&gt; awk &#39;{print $0}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Name Age Unit
  Ant  23  IT
  Bec  25  HR
  Red  34  CEO
  Dua  32  FIN
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; awk &#39;{print $1}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Name
  Ant
  Bec
  Red
  Dua
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; awk &#39;{print $2}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Age
  23
  25
  34
  32
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; awk &#39;{print $3}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Unit
  IT
  HR
  CEO
  FIN
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; awk &#39;{print $1,$3}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Name Unit
  Ant IT
  Bec HR
  Red CEO
  Dua FIN
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;search-patterns-&#34;&gt;Search Patterns :&lt;/h3&gt;
&lt;p&gt;Awk performs operations line by line. Search pattern is defined between &amp;lsquo;//&amp;rsquo;.
AWK uses the default Regular Expressions&lt;/p&gt;
&lt;p&gt;eg 1 :   &lt;code&gt; awk &#39; /CEO/ {print $1,$3}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;output:
    Red CEO
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nf---number-of-fields-&#34;&gt;NF - Number of Fields :&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;1 two 3 four&amp;quot; | awk &#39;{print NF}&#39;&lt;/code&gt; Output : &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;1 two 3 four&amp;quot; | awk &#39;{print $(NF-2)}&#39;&lt;/code&gt; Output : &lt;code&gt;two&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$NF = 4 and using this we could do mathemetical operations. Eg. To print the second last field we could &amp;lsquo;{print $(NF-1)}&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nr---number-of-records-&#34;&gt;NR - Number of Records :&lt;/h3&gt;
&lt;p&gt;Records in Awk are by default seperated by a newline.&lt;/p&gt;
&lt;p&gt;Eg 1: &lt;code&gt; echo &amp;quot;1 two 3 four&amp;quot; | awk &#39;{print $(NR)}&#39;&lt;/code&gt; . Output : &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Eg 2:  &lt;code&gt; awk &#39;{print NR}&#39; emp.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Output:
    1
    2
    3
    4
    5
    6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;code&gt;awk&lt;/code&gt; processess line by line, for each line it prints the nos. of records found.&lt;/p&gt;
&lt;p&gt;To print exact records from a file we could use &lt;code&gt;END&lt;/code&gt;.
Eg: &lt;code&gt;awk &#39;END{print NR}&#39; emp.txt&lt;/code&gt;. Output : &lt;code&gt;6&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;fs---field-seperator-&#34;&gt;FS - Field Seperator :&lt;/h3&gt;
&lt;p&gt;Default is space. We can define custom values for the field seperator.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;echo &amp;quot;102 202 303&amp;quot; | awk &#39;BEGIN{FS=&amp;quot;0&amp;quot;} {print $1&amp;quot;-&amp;quot;$2&amp;quot;-&amp;quot;$3&amp;quot;-&amp;quot;$4}&#39; &lt;/code&gt; . Output of the above command : &lt;code&gt;  1-2 2-2 3-3&lt;/code&gt; . We used &lt;code&gt;0&lt;/code&gt; as FS.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rs---record-seperator-&#34;&gt;RS - Record Seperator :&lt;/h3&gt;
&lt;p&gt;By default seperated by newline. Can devine custom values for RS (record seperator).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;echo &amp;quot;102 202 303&amp;quot; | awk &#39;BEGIN{RS=&amp;quot;0&amp;quot;} END{print NR}&#39;&lt;/code&gt; . Output is &lt;code&gt;4&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now the default RS would return 1. as there is only one line. Eg. &lt;code&gt;echo &amp;quot;102 202 303&amp;quot; | awk &#39;END{print NR}&#39;&lt;/code&gt;  Output : &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;awk-variables-&#34;&gt;AWK Variables :&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Assignment :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RS=&amp;quot;\t&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FS=&amp;quot;:&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Increment/ Decrement :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a++ / a--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt; a=a+1 / a=a-1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Math Operations :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a=b+c&lt;/code&gt; add&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b*c&lt;/code&gt; multiply&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b/c&lt;/code&gt; divide&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b-c&lt;/code&gt; subtract&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b%c&lt;/code&gt; Modulus&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b^c&lt;/code&gt; Raise var to the power&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a=b**c&lt;/code&gt; Raise var to the power&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;awk---if-statement&#34;&gt;AWK - if Statement&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    if(condition){
            command(s)
    }
    else{
        command(s)    
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Comparisons:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg: &lt;code&gt;awk &#39;{if ($1 == &amp;quot;Red&amp;quot;){print $1, $2, $3}}&#39; emp.txt&lt;/code&gt;. Output would be : &lt;code&gt;Red  34  CEO&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;OR if we want to print all fields we could also use $0 instead. Eg: &lt;code&gt;awk &#39;{if ($1 == &amp;quot;Red&amp;quot;){print $0}}&#39; emp.txt&lt;/code&gt; Output :  &lt;code&gt;Red  34  CEO&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;awk-for-loops&#34;&gt;AWK For loops&lt;/h3&gt;
&lt;p&gt;Structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (initialization; condition; increment){
        command(s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Eg: &lt;code&gt;awk &#39;BEGIN{for(i=1; i&amp;lt;=3; i++){print &amp;quot;test -&amp;quot;, i}}&#39;&lt;/code&gt;
Output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  test - 1
  test - 2
  test - 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;awk-script-files-&#34;&gt;AWK Script files :&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Structure :  &lt;code&gt; awk -f awkscript inputfiles&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bash Scripting Tutorial</title>
      <link>https://hacktheripper.com/essentials/scripting-bash/</link>
      <pubDate>Mon, 21 Sep 2020 15:51:19 +0530</pubDate>
      <guid>https://hacktheripper.com/essentials/scripting-bash/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Credits -&lt;/strong&gt; These are my notes from 
&lt;a href=&#34;https://www.udemy.com/course/linux-bash-shell-scripting-complete-guide-incl-awk-sed/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richard Bohm&amp;rsquo;s Udemy Class&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;scriptitng-basics&#34;&gt;Scriptitng Basics&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#!/bin/bash&lt;/code&gt; Sha-Bang. # -Sharp !- Bang   /bin/bash - invoke bash interpreter. If this line is not added all scripts would be run by &lt;code&gt; /bin/bash  script.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls -l /bin/sh&lt;/code&gt; Default shell (eg&amp;gt; in Ubuntu : /bin/sh  &amp;raquo; dash )&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./file.sh&lt;/code&gt; Execute the script in current directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo $PATH&lt;/code&gt; If file.sh path defined in PATH then file.sh can be invoked anywhere by typing the file name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export PATH=$PATH:(path/of/file)&lt;/code&gt; to export path. Eg. &lt;code&gt;export PATH=$PATH:$(pwd)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;variables&#34;&gt;Variables&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;3 Ways to assign values to a variable
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VAR=value&lt;/code&gt; Explicit definition (no spaces after =. If space is added bash sees it as 2 arguments after VAR)
&lt;ul&gt;
&lt;li&gt;PATH=/var/lib&lt;/li&gt;
&lt;li&gt;Count =12&lt;/li&gt;
&lt;li&gt;msg=&amp;quot;hello world&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read VAR&lt;/code&gt; Read Command
eg: &lt;code&gt;echo -n &amp;quot;Enter age:&amp;quot;&lt;/code&gt;
&lt;code&gt;read AGE&lt;/code&gt;
&lt;code&gt; echo -n &amp;quot;Age is $AGE&amp;quot;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read -p &amp;quot;Name: &amp;quot; NAME &lt;/code&gt; Read value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read -sp &amp;quot;Pword: &amp;quot; PASS&lt;/code&gt;  Read value but Entered value is NOT displayed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read HOST &amp;lt; /etc/hostname&lt;/code&gt; Read the value of file /rtc/hostname to HOST var. Equal to assiging the output of cat /etc/hostname to the variable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VAR=$(cmd) eg: VAR=$(pwd)&lt;/code&gt; Command substitution
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VAR=$(cmd) eg: VAR=$(pwd)&lt;/code&gt; $ prepend&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VAR=`cmd` eg: VAR=`pwd`.&lt;/code&gt; using backticks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Accessing variables
&lt;ul&gt;
&lt;li&gt;Access variables by prepending &amp;lsquo;$&amp;rsquo;&lt;/li&gt;
&lt;li&gt;eg:&lt;code&gt;COUNT =10 echo &amp;quot;counter = $COUNT &amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;math&#34;&gt;Math&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;let
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NUMBER=5   let Result=NUMBER+5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Increment &lt;code&gt;let NUMBER++&lt;/code&gt; ( i.e let NUMBER+=5)&lt;/li&gt;
&lt;li&gt;Decrement &lt;code&gt;let NUMBER--&lt;/code&gt; ( i.e let NUMBER-=5)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(()) - Eg:  &lt;code&gt;RESULT=$(( NUMBER + 5 ))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[] - Eg: &lt;code&gt;RESULT=$[ NUMBER + 5 ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;expr &amp;ndash; Need to add spaces around math operators
&lt;ul&gt;
&lt;li&gt;eg: &lt;code&gt;RESULT=$(expr $NUM1 + $NUM2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg: &lt;code&gt;RESULT=`expr $NUM1 + $NUM2` Alternate approach&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;bc  - OPERATE FLOATING POINT. Put Mathematical expression in &amp;quot;&amp;rdquo; and | bc
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;AREA=`echo &amp;quot;2 *$RADIUS * 3.14&amp;quot;|bc`&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arguments&#34;&gt;Arguments&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Passing args to scripts&lt;/li&gt;
&lt;li&gt;Passing args into function&lt;/li&gt;
&lt;li&gt;Eg: Calling script with args &lt;code&gt; ./arg.sh A1 A2 A3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arguments - Accessing them from scripts
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$0 &lt;/code&gt;-  script name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$1 &lt;/code&gt;- 1st arg&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$2 &lt;/code&gt;- 2nd arg&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$n &lt;/code&gt;- Nth arg&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;$@&amp;quot; &lt;/code&gt;- all args, expands as &amp;ldquo;$1&amp;rdquo; &amp;ldquo;$2&amp;rdquo; &amp;ldquo;$3&amp;rdquo; etc .&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;$*&amp;quot; &lt;/code&gt;- all args, expand as one string &amp;ldquo;$1c$2c$3c&amp;rdquo; where c is the first character of IFS (internal dield space) usually its space.
&lt;ul&gt;
&lt;li&gt;View default IFS first char &lt;code&gt;set | grep ^IFS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;To change IFS simply use var IFS=&amp;quot;&lt;char&gt;&amp;rdquo; .Eg: &lt;code&gt;IFS=&amp;quot;,&amp;quot;&lt;/code&gt; to change IFS char to&lt;code&gt; ,&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$# &lt;/code&gt;- Args count.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redirection--piping&#34;&gt;Redirection &amp;amp; Piping&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;STDIN (0) - STD input (data provided to the program)&lt;/li&gt;
&lt;li&gt;STDOUT (1) - STD output (what program prints.. default to the terminal)&lt;/li&gt;
&lt;li&gt;STDERR (2) - STD error (error msgs program prints)&lt;/li&gt;
&lt;li&gt;Redirection &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; to append
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;cat file.txt &amp;gt; output.txt &lt;/code&gt;&amp;ndash; Redirect std output&lt;/li&gt;
&lt;li&gt;Eg: &lt;code&gt;cat file.txt 1&amp;gt; output.txt &lt;/code&gt;&amp;ndash; (Same as above) Redirect std output&lt;/li&gt;
&lt;li&gt;Eg:&lt;code&gt;cat file.txt 2&amp;gt; output.txt&lt;/code&gt;&amp;ndash; Redirect std error&lt;/li&gt;
&lt;li&gt;Eg: &lt;code&gt;cat file.txt 1&amp;gt; output.txt 2&amp;gt; error.log &lt;/code&gt;&amp;ndash; Redirect std out and std error to 2 files&lt;/li&gt;
&lt;li&gt;Eg: &lt;code&gt;cat file.txt 1&amp;gt; output.txt 2&amp;gt;&amp;amp;1 &lt;/code&gt;&amp;ndash; Redirect std err stream to std out stream&lt;/li&gt;
&lt;li&gt;Eg: &lt;code&gt;cat file.txt &amp;amp;&amp;gt; output.txt &lt;/code&gt;&amp;ndash; Redirect std out and std error to one file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wc -l file.txt&lt;/code&gt;  Vs &lt;code&gt;wc -l &amp;lt; file.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Piping &lt;code&gt;|&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;sending output of one cmd to another&lt;/li&gt;
&lt;li&gt;eg: &lt;code&gt;cat file | head -5 | tail -2 wc -l &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exit Status &lt;code&gt;echo $?&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;0 - successful&lt;/li&gt;
&lt;li&gt;non-zero - not successful&lt;/li&gt;
&lt;li&gt;exit 0,  exit1 &amp;hellip;. exit 255&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;if-else&#34;&gt;If Else&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    if [cond] 
    then
    statements
    fi  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;AND &amp;amp;&amp;amp; , OR || , NOT !&lt;/li&gt;
&lt;li&gt;if elif else&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;for-loops&#34;&gt;For Loops&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;For Eg: &lt;code&gt;for p in a b c; do echo $p; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For on string &lt;code&gt; $STR=A cool char&lt;/code&gt; will print each word on a newline &lt;code&gt;for p in $STR; do echo $p; done&lt;/code&gt;. And if &lt;code&gt;for p in &amp;quot;$STR&amp;quot;; do echo $p; done&lt;/code&gt; output of $STR will be printed in one line. The default IFS is space &lt;code&gt;IFS=$&#39;\t\n&#39;&lt;/code&gt; this can be changed and For will behave accordingly.&lt;/li&gt;
&lt;li&gt;Eg. Print all txt files &lt;code&gt;for p in *.txt; do echo $p; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Eg. Range &lt;code&gt;for p in {1..10}; do echo $p; done&lt;/code&gt; loop through 1 to 10&lt;/li&gt;
&lt;li&gt;Eg. Loop through arguments &lt;code&gt;for ARG in &amp;quot;$@&amp;quot;; do echo $ARG; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C-Style Incremental and decremental &lt;code&gt; for ((i=1; i&amp;lt;=12; i++)); do echo &amp;amp;i; done&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;while-loop&#34;&gt;While Loop&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Syntax &lt;code&gt;while [cond]; do [action]; done&lt;/code&gt; Eg: &lt;code&gt;while true; do ping 8.8.8.8; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reading Files with While Loop :
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;while read line; do echo $line; done &amp;lt; &amp;quot;$FILENAME&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;cat &amp;quot;$FILENAME&amp;quot; | while read line; do echo $line; done&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;case&#34;&gt;Case&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;case &amp;quot;$VAR&amp;quot; in 
&amp;quot;$cond1&amp;quot;)
  commands...
  ;;
&amp;quot;$cond2&amp;quot;)
  commands..
  ;;
 *)
  commands
  ;;
esac  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;shift &lt;a href=&#34;https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html&#34;&gt;https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;math-operands&#34;&gt;Math Operands&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-eq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ne&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-gt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-lt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-le&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;string-comparision&#34;&gt;String Comparision&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Compare 2 strings (notice the spaces)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ &amp;quot;$Str1&amp;quot; = &amp;quot;$Str2&amp;quot; ]&lt;/code&gt; equals&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ &amp;quot;$Str1&amp;quot; != &amp;quot;$Str2&amp;quot; ]&lt;/code&gt; not equals&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ &amp;quot;$Str1&amp;quot; = &amp;quot;Hello&amp;quot; ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ &amp;quot;$Str1&amp;quot; != &amp;quot;Hello&amp;quot; ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 = $Str2 ]]&lt;/code&gt; equals with []&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 != $Str2 ]]&lt;/code&gt; not equals  []&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 = Hello ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 != Hello ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 = &amp;quot;Hello&amp;quot; ]]&lt;/code&gt;  [] and &amp;ldquo;string&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 != &amp;quot;Hello&amp;quot; ]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Test if string is empty&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ -z &amp;quot;$Str1&amp;quot; ]&lt;/code&gt; - returns true if Str1 holds an empty string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -n &amp;quot;$Str1&amp;quot; ]&lt;/code&gt; - rteturns if the Str1 holds a non-empty string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ -z $Str1 ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ -n $Str1 ]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alphabetically compare 2 strings&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 &amp;gt; $Str2 ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ $Str1 &amp;lt; $Str2 ]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wildcards&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; Single character eg: hel? (hell,held,help ..etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; Any nos. of characters eg: hel* (helll, helljdkljd, hel12 .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; Single character from a range. eg: hel[pqr]; hel[4-7] (help, helq. helr) (hel4, hel5, hel6, hel7)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; Comma seperated terms. eg: {*.txt, *.exe} (a.exe, b.txt, c.txt .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[!]&lt;/code&gt; Any Character not listed eg: hel[!p] (hell, helo, helx .. etc)&lt;/li&gt;
&lt;li&gt;Gobbling patterns (character classes)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[:upper:]&lt;/code&gt; - Uppercase character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:lower:]&lt;/code&gt; - Lowercase character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alpha:]&lt;/code&gt; - Alphabetic character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:digit:]&lt;/code&gt; - Number character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alnum:]&lt;/code&gt; - Alphanumeric character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:space:]&lt;/code&gt; - Whitespace character (space, tab, newline)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Wildcards in string Comparision &lt;code&gt;[[ $STR == &amp;lt;pattern&amp;gt; ]] &lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;eg:&lt;code&gt; [[ $STR == *.sh ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg:&lt;code&gt; [[ $STR == log[1-9].txt ]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg:&lt;code&gt; [[ $STR == conf* ]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RegEx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; Any single Character eg: hel. (help, hell, helo .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; Preceding Character must match 0 or more times eg: he*lo (hlo, helo, heeeelo, heelo .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; Preceding Character must match 1 or 0 times eg: he?lo (helo, hlo)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; Start of the line marker eg: ^Hello (Line starting with Hello)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; End of the line marker eg: hello$ (Line ending with hello)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; Any of the characters enclosed in [] eg: Hel[lop] (Hell, Helo, Help)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[-]&lt;/code&gt; Any of the characters within the range eg: file[1-3] (file1, file2, file3)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[^]&lt;/code&gt; Any of the characters except the ones enclosed in [] eg: file[^13] (file0, file2, file4 &amp;hellip;etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; Preceding item must match 1 or more times eg: file+ (file, files, file1, filex &amp;hellip; etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; Preceding item must match n times eg: [0-9]{3} (Any 3 digit no .. 111, 134, 098, 678 .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n, }&lt;/code&gt; Preceding item must match at least n times eg: [0-9]{3} (Any 3 or more digit no .. 111, 134, 0981, 67887, 71236 .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; Minimum and maximum nos of times the preceding item must match. eg: [0-9]{2,3} (Any 2 or 3 digit no .. 111, 134, 98, 78 .. etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt; Escape Character eg: he*ro (he*ro)&lt;/li&gt;
&lt;li&gt;Reg Ex Character classes :
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[:upper:]&lt;/code&gt; - Uppercase character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:lower:]&lt;/code&gt; - Lowercase character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alpha:]&lt;/code&gt; - Alphabetic character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:digit:]&lt;/code&gt; - Number character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alnum:]&lt;/code&gt; - Alphanumeric character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:space:]&lt;/code&gt; - Whitespace character (space, tab, newline)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reg Ex in Bash: &lt;code&gt;[[ $STR =~ $REGEX ]] &lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;eg: &lt;code&gt;REGEX=&amp;quot;http://.*\.jpg&amp;quot;&lt;/code&gt; (eg: &lt;a href=&#34;http://images.jpg&#34;&gt;http://images.jpg&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${BASH_REMATCH[0]} &lt;/code&gt;- Part of the STR which matches REGEX eg: (&lt;a href=&#34;http://images.jpg&#34;&gt;http://images.jpg&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${BASH_REMATCH[1]} &lt;/code&gt;- Part of the REGEX which is enclosed in the first parentheses eg: &lt;code&gt;REGEX=&amp;quot;http://(.*)\.jpg &lt;/code&gt;which reperesents as &amp;ldquo;images&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;File System Related Tests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ -e $VAR ] &lt;/code&gt; - True if variable holds an existing file or dir.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -f $VAR ] &lt;/code&gt; - True if variable holds an existing regular file.
&lt;ul&gt;
&lt;li&gt;eg: &lt;code&gt;if [-f $FILE]; then   echo &amp;quot;$FILE exists&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -d $VAR ] &lt;/code&gt; - True if variable holds an existing dir.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -x $VAR ] &lt;/code&gt; - True if variable holds an executable file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -L $VAR ] &lt;/code&gt; - True if variable holds the path of a symlink.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -r $VAR ] &lt;/code&gt; - True if variable holds an existing file thats readable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ -w $VAR ] &lt;/code&gt; - True if variable holds an existing file thats writable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using &amp;amp;&amp;amp; and ||&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;if [ -f file.txt ]; then echo exists; else echo does not exists; fi&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&amp;amp;&amp;amp; return if true &lt;code&gt;if [ -f file.txt ] &amp;amp;&amp;amp; echo exists&lt;/code&gt; Output: &amp;ldquo;exists&amp;rdquo; if file.txt exists&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;|| return if false &lt;code&gt;if [ -f filex.txt ] || echo does not exist&lt;/code&gt; Output: &amp;ldquo;does not exist&amp;rdquo; as filex.txt is not present.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;If else &lt;code&gt;if [ -f filex.txt ]  &amp;amp;&amp;amp; echo exists || echo does not exist&lt;/code&gt; eg. &lt;code&gt;if [ $? -eq 0 ]  &amp;amp;&amp;amp; echo exists || echo does not exist&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Argument Parsing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Manual parsing using Case statements with &lt;code&gt;shift&lt;/code&gt; (&lt;a href=&#34;https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html&#34;&gt;https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt; getopts()&lt;/code&gt; - easy way to parse short positional params (-f). Does not support long positional params (&amp;ndash;help)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getopt()&lt;/code&gt; Enchanced version of getopts()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;opts=`getopt -o a:ð±ï¸cd --long file::,name:,help -- &amp;quot;$@&amp;quot; `&lt;/code&gt;; &lt;code&gt;eval set --&amp;quot;$opts&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval set --&amp;quot;$opts&amp;quot;&lt;/code&gt; is used to parse script arguments.&lt;/li&gt;
&lt;li&gt;Short parameters specified after &lt;code&gt;-o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Long parameters specified after &lt;code&gt;--long&lt;/code&gt; and parameters have to seperated by &lt;code&gt;,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the end specify all arguments with &lt;code&gt;-- &amp;quot;$@&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt;  - Parameters with a required argument.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::&lt;/code&gt; - Parameters can be followed by optional parameters.
&lt;ul&gt;
&lt;li&gt;For short parameters specify optional args without spaces. Eg.&lt;code&gt;./script.sh -ab &lt;/code&gt; where b is an optional arg.&lt;/li&gt;
&lt;li&gt;For long parameters specify optional args with &lt;code&gt;=&lt;/code&gt;. Eg. &lt;code&gt;./script.sh --file=test.txt &lt;/code&gt; where test.txt is an optional arg.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;getopts--optarg-example&#34;&gt;getopts() (: $OPTARG) example:&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;while getopts að±ï¸cd param; 
do
case $param in
    a) echo &amp;quot;param &#39;a&#39; with Argument. Access argument using $OPTARG&amp;quot; 
    ;;
    b) echo &amp;quot;param &#39;b&#39; with Argument. Access argument using $OPTARG&amp;quot;
    ;;
    c) echo &amp;quot;param &#39;c&#39; without Argument (no colon)&amp;quot;
    d) echo &amp;quot;param &#39;d&#39; without Argument (no colon)&amp;quot;
esac
done
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;getopt-example-&#34;&gt;getopt() example :&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo &amp;quot;All args: $@&amp;quot;
opts=`getopt -o a:ð±ï¸cd --long file::,name:,help -- &amp;quot;$@&amp;quot;`
eval set -- &amp;quot;$opts&amp;quot;
echo &amp;quot;All args after getopt: $@&amp;quot;

while [ $# -gt 0 ]
do
    case &amp;quot;$1&amp;quot; in
            -a) echo &amp;quot;param &#39;a&#39; - arg $2 &amp;quot;
            ;;
            -b) echo &amp;quot;param &#39;b&#39; -arg $2 &amp;quot;
                shift 2
            ;;
            -c) echo &amp;quot;param &#39;c&#39;&amp;quot;
                shift 2
            ;;
            -d)  echo &amp;quot;param &#39;d&#39;&amp;quot;
                shift 2
            ;;
            --file) echo &amp;quot;param &#39;file&#39; with arg $2 &amp;quot;
                shift 2
            ;;
            --name) echo &amp;quot;param &#39;name&#39; with arg $2&amp;quot;
                shift 2
            ;;
            --help) echo &amp;quot;paaram &#39;help&#39;&amp;quot;
                shift 2
            ;;
            *)  shift
            ;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;arrays&#34;&gt;Arrays&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Declaring Arrays:
&lt;ul&gt;
&lt;li&gt;ARRAY=(val1 val2 &amp;hellip; valN)&lt;/li&gt;
&lt;li&gt;eg:  &lt;code&gt;ARRAY=(a,b,c) &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Calling Arrays
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${ARRAY[0]}&lt;/code&gt; # a&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${ARRAY[1]}&lt;/code&gt; # b&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${ARRAY[2]}&lt;/code&gt;  # c&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other ways to call arrays
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${ARRAY[@]}&lt;/code&gt; # ALL items in an array&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${ARRAY[*]}&lt;/code&gt; # All items in an Array, delimited by first character of IFS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${!ARRAY[@]}&lt;/code&gt; # All indexes in the array (@/*)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${#ARRAY[@]}&lt;/code&gt; # Number of items in the array (@/*)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${#ARRAY[0]}&lt;/code&gt; # Length of item 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;functions&#34;&gt;Functions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Syntax:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function_name () {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OR &lt;code&gt;function function_name {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Declaration of the functions should be before calling&lt;/li&gt;
&lt;li&gt;Use of &lt;code&gt;local&lt;/code&gt; variables in functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Git Tutorial</title>
      <link>https://hacktheripper.com/essentials/git-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hacktheripper.com/essentials/git-basics/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Credits -&lt;/strong&gt; These are my notes from Corey Schafer&amp;rsquo;s Youtube series -  
&lt;a href=&#34;https://www.youtube.com/playlist?list=PL-osiE80TeTuRUfjRe54Eea17-YfnOOAx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git Tutorials - by Corey Schafer.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;fundamentals&#34;&gt;&lt;strong&gt;Fundamentals&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Git is a Distributed version control. &amp;hellip;Git has a local and remote repositories.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git  --version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git help &amp;lt;verb&amp;gt;  OR  git &amp;lt;verb&amp;gt; --help&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set Configs values :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name &amp;quot;Jon Doe&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global user.email &amp;quot;jondoe@example.com&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --list&lt;/code&gt;   - all values will be listed&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scenario-1--existing-project-local&#34;&gt;&lt;strong&gt;Scenario 1 : Existing Project Local&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd  /project_dir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git init&lt;/code&gt;    // Initializes a git repo .. creates a .git/ dir&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git status&lt;/code&gt;   // Check status&lt;/li&gt;
&lt;li&gt;&lt;code&gt; touch .gitignore &lt;/code&gt;  // .txt file to add files dirs to be ignored by git.&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git add -A &lt;/code&gt; // add all files to staging area.
&lt;ul&gt;
&lt;li&gt;Eg: &lt;code&gt;  git add .gitignore&lt;/code&gt;  // add .gitignore to the repo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git commit -m &amp;quot;&amp;lt;message&amp;gt;&amp;quot; &lt;/code&gt; // make changes to the local repo&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git reset &lt;/code&gt; // remove files from staging&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git log  &lt;/code&gt; // log&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scenario-2--remote-project-repo&#34;&gt;&lt;strong&gt;Scenario 2 : Remote Project Repo&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone &amp;lt;url&amp;gt; &amp;lt;location_to_clone&amp;gt;&lt;/code&gt;  //clone remote repo to local system&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote -v&lt;/code&gt; //  view info about the remote repo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -a&lt;/code&gt; // list all branches in the repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;After making changes to the code, commit the changes locally before pushing&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt; // shows changes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt; // shows the modified files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add -A&lt;/code&gt; // add all files to staging&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt; // shows files are ready to be committed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;&amp;lt;message&amp;gt;&amp;quot;&lt;/code&gt;  // commit changes locally&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull origin master &lt;/code&gt; // pull latest code (in case there are more people working on the repo)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin master &lt;/code&gt; // push changes to master branch on remote.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:Instead of working on the master branch, its recommended to create a branch of the feature to work on.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch -a&lt;/code&gt;  // list branches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch &amp;lt;branch_name&amp;gt;&lt;/code&gt; // Create new branch&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt; // switch to &amp;lt;branch_name&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;make changes to the code&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;&amp;lt;message&amp;gt;&amp;quot;&lt;/code&gt; // commit changes to &amp;lt;branch_name&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push -u origin &amp;lt;branch_name&amp;gt;&lt;/code&gt; // push changes to &amp;lt;branch_name&amp;gt; on remote repo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Now we need to Merge the changes in the custom branch to the master &amp;amp; then delete the custom branch.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git checkout master&lt;/code&gt;  // switch to master branch&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git  pull origin master&lt;/code&gt; // pull the latest code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch  --merged &lt;/code&gt; // lists the branches that have been merged so far&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge &amp;lt;branch_name&amp;gt;&lt;/code&gt; // Merge changes from &amp;lt;branch_name&amp;gt; to master.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin master&lt;/code&gt; // push the merged changes to master.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch --merged&lt;/code&gt; // check if the changes from &amp;lt;branch_name&amp;gt; have been merged.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -d &amp;lt;branch_name&amp;gt;&lt;/code&gt; // Deletes branch locally&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin --delete &amp;lt;branch_name&amp;gt;&lt;/code&gt; // delete branch from remote repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;undoing-bad-commits&#34;&gt;&lt;strong&gt;Undoing Bad commits&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff &lt;/code&gt; //see the code changes made&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. In case we want to change the commit message&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;Wrong message&amp;quot; &lt;/code&gt; // user enter a wrong commit message&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log &lt;/code&gt; // check the message in logs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit --amend -m &amp;quot;Correct message&amp;quot;&lt;/code&gt; // Amends the commit message&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log &lt;/code&gt; // double-check in logs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. In case of a committed file (Accidentally made changes to wrong branch)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Eg.  Changes committed to master instead of feature branch&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git log --stat&lt;/code&gt; // git files changed within the commit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout master&lt;/code&gt; // switch to master.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt;// copy 5-6 chars of the commit hash&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout feature&lt;/code&gt; // switch to feature branch&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git cherry-pick &amp;lt;copied commit hash&amp;gt;&lt;/code&gt; // copied above commit hash&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt; // commit from master is now in feature branch&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout master&lt;/code&gt; // go back to master branch&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;git-reset&#34;&gt;&lt;strong&gt;Git Reset&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Git Reset Soft:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git reset --soft &amp;lt;commit hash_str&amp;gt;&lt;/code&gt;
In this case the &lt;code&gt;&#39;git log&#39; &lt;/code&gt; will no longer have the commit but in the &amp;lsquo;git status&amp;rsquo; the changes will be as it is in the staging. So we wont lose any work.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Git Reset (Default/Mixed) :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; git reset &amp;lt;commit hash_str&amp;gt;&lt;/code&gt;
In this case the &lt;code&gt;&#39;git log&#39;&lt;/code&gt; will no longer have the commit just as &lt;code&gt;git --soft&lt;/code&gt; but in this case the changes will move out of the staging area to the working area.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Git Reset  Hard:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git reset --hard &amp;lt;commit hash_Str&amp;gt;&lt;/code&gt;
In this case  modifications will be completely reverted. Except for the un-tracked files.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;To get rid of untracked files and directories :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; git clean -df&lt;/code&gt;  // -d for dirs; f for force&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;In case you run &#39;&amp;rsquo; git reset &amp;ndash;hard&amp;rdquo;  by mistake:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; git reflog&lt;/code&gt; // shows commits in the order of when we last referenced them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git checkout &amp;lt;commit hash_str&amp;gt;&lt;/code&gt; // Checkout to the commit hash obtained from above reflog.&lt;/li&gt;
&lt;li&gt;&lt;code&gt; git branch backup&lt;/code&gt; //create a backup of the previous rollback.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Git Garbage collector run once in 30 days and above retrieval will  work prior to the garbage collector running.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;git-revert&#34;&gt;Git Revert:&lt;/h3&gt;
&lt;p&gt;Git revert un-does the changes and adds additional commits of the changes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; git revert &amp;lt;commit hash_str&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git Stash :  [pending ]&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P.S: Originally written on my 
&lt;a href=&#34;https://hacktheripper.blogspot.com/2020/07/notes-git-basics-git-commands.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blogger&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
